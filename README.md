# PlayPod - Музыкальный плеер(веб-сайт)

## Краткое описание проекта

PlayPod - это простое веб-приложение для прослушивания музыки, построенное с использованием Flask, SQLite и стандартных веб-технологий. Приложение позволяет пользователям просматривать альбомы и песни, искать музыку по названию и исполнителю, фильтровать песни по жанрам, управлять списком избранных песен, создавать собственные плейлисты и просматривать историю прослушиваний.

## Инструкции по установке и запуску

Для установки и запуска PlayPod выполните следующие шаги:

1.  **Клонируйте репозиторий:**
    ```bash
    git clone "https://github.com/miras888/playpod"
    cd <название папки проекта>
    ```
    (Замените `<название папки проекта>` на актуальные значения).

2.  **Создайте виртуальное окружение (рекомендуется):**
    ```bash
    python -m venv venv
    ```

3.  **Активируйте виртуальное окружение:**
    * На Windows:
        ```bash
        venv\Scripts\activate
        ```
    * На macOS и Linux:
        ```bash
        source venv/bin/activate
        ```

4.  **Установите библеотеки:**
    Убедитесь, что у вас есть файл `requirements.txt`. Затем установите библеотеки:
    ```bash
    pip install -r requirements.txt
    ```

5.  **Инициализация базы данных:**
    При первом запуске база данных SQLite (`playpod.db`) будет создана автоматически. Вам может понадобиться скрипт `schema.sql` для создания необходимых таблиц и наполнения их начальными данными (альбомы, песни). Выполните его вручную с помощью инструмента командной строки SQLite или через скрипт Python, если это предусмотрено в вашем проекте.

6.  **Установите переменную окружения FLASK_APP:**
    ```bash
    export FLASK_APP=app.py # Для macOS и Linux
    set FLASK_APP=app.py # Для Windows
    ```

7.  **Запустите приложение Flask:**
    ```bash
    flask run
    ```

8.  **Откройте приложение в браузере:**
    Перейдите по адресу, который будет указан в консоли (обычно `http://127.0.0.1:5000/`).

## Описание процесса проектирования и разработки

Разработка PlayPod следовала итеративному подходу. Процесс начался с реализации базового функционала: аутентификация пользователей (регистрация, вход, выход) и отображение статического контента или простых списков (альбомы, песни).

Постепенно добавлялись более сложные возможности:
- Динамическое отображение деталей альбома и его песен.
- Реализация поиска и фильтрации через параметры URL.
- Добавление функционала избранных песен с использованием AJAX для улучшения пользовательского опыта.
- Разработка системы плейлистов, включающей создание, просмотр, добавление/удаление песен и удаление плейлистов.
- Внедрение истории прослушиваний с фиксацией времени воспроизведения при переходе на страницу проигрывателя.

Процесс часто включал отладку и рефакторинг по мере выявления проблем (например, с транзакциями базы данных при сложных операциях или взаимодействием клиент-сервер).

## Информация об уникальных подходах или методологиях, использованных в работе

В ходе разработки были применены стандартные, но эффективные для веб-приложений данного масштаба подходы:
- **Модель MVC-подобная структура:** Разделение логики на маршруты Flask (контроллеры), шаблоны Jinja2 (представления) и взаимодействие с базой данных через `cs50.SQL` (модель).
- **Использование сессий:** Для управления состоянием пользователя (вход в систему).
- **AJAX для интерактивности:** Применение асинхронных запросов (для избранного) для частичного обновления страницы без полной перезагрузки.
- **Явные транзакции:** В случае сложных операций с базой данных (как при удалении плейлиста) использовались явные команды `BEGIN TRANSACTION`, `COMMIT`, `ROLLBACK` через `cs50.SQL` для обеспечения атомарности операций.
- **Параметризованные запросы:** Использование `?` в SQL-запросах с последующей передачей параметров для предотвращения SQL-инъекций.

## Обсуждение компромиссов, принятых во время разработки

В процессе разработки были приняты следующие компромиссы, часто связанные с балансом между функциональностью, сложностью реализации и сроками:

1.  **Выбор технического стека:** Использование Flask и `cs50.SQL` обеспечивает быструю разработку и простоту настройки, но `cs50.SQL` является относительно простым инструментом и может иметь ограничения по сравнению с более мощными ORM (как SQLAlchemy) или нативными драйверами при работе со сложными транзакциями или специфическими функциями базы данных.
2.  **Реализация плеера:** Изначальная идея интегрированного мини-плеера была изменена в пользу более простого подхода с независимой страницей плеера. Это упростило разработку и отладку взаимодействия между компонентами, но отказалось от возможности непрерывного воспроизведения при навигации.
3.  **AJAX против полной перезагрузки:** AJAX реализован только для управления избранными песнями. Для других действий (добавление/удаление из плейлиста через страницы управления, фильтрация) используются полные перезагрузки страницы, что является компромиссом в пользу более быстрой реализации по сравнению с созданием полноценного Single Page Application (SPA).
4.  **Упрощенное создание плейлистов:** Отказ от генерации плейлистов на основе настроения в пользу простого создания по названию и последующего добавления песен вручную упростил логику и пользовательский интерфейс.

## Описание известных ошибок или проблем в приложении

* **Автозапуск аудио:** В зависимости от браузера и его настроек, автозапуск аудио при загрузке страницы плеера может быть заблокирован. Пользователю может потребоваться вручную нажать кнопку воспроизведения.
* **Обработка ошибок запросов к базе данных:** Хотя добавлен общий блок `try...except` для критических операций, более детальная обработка специфических ошибок базы данных может потребоваться в продакшене.
* **Масштабируемость:** Использование SQLite и `cs50.SQL` подходит для небольших проектов и целей обучения, но может стать узким местом при значительном росте количества пользователей и данных.
* **Перенаправления после действий:** В некоторых случаях перенаправления после добавления/удаления из плейлиста могут возвращать пользователя не на самую интуитивную страницу (например, на список всех песен вместо альбома или плейлиста), хотя в последних изменениях использовался `request.referrer` для попытки вернуться на предыдущую страницу.

## Объяснение выбора технического стека

Выбор данного технического стека обусловлен несколькими факторами:

* **Python и Flask:** Python - это популярный и легкочитаемый язык программирования, а Flask - это микрофреймворк, который является минималистичным, гибким и простым для изучения. Он идеально подходит для разработки небольших и средних веб-приложений, позволяя быстро приступить к работе без избыточной сложности.
* **SQLite:** SQLite - это легковесная, файловая база данных, которая не требует отдельного сервера. Это делает ее чрезвычайно удобной для разработки, тестирования и развертывания небольших приложений, поскольку все данные хранятся в одном файле.
* **`cs50.SQL`:** Эта библиотека предоставляет упрощенный интерфейс для взаимодействия с базами данных, что удобно для быстрого прототипирования и в образовательных целях. Она абстрагирует некоторые детали работы с низкоуровневыми драйверами базы данных.
* **HTML, CSS, JavaScript:** Это фундаментальные технологии веб-разработки, необходимые для создания интерфейса, обеспечения стилизации и добавления интерактивности на стороне клиента.
* **Bootstrap:** Популярный CSS-фреймворк, который ускоряет разработку адаптивного и современно выглядящего пользовательского интерфейса за счет готовых компонентов и утилит.
* **Werkzeug и Jinja2:** Являясь базовыми компонентами Flask, они обеспечивают мощные возможности для обработки HTTP-запросов/отвесов и создания динамических веб-страниц с использованием шаблонов.

Этот стек предоставляет хороший баланс между простотой, скоростью разработки и достаточной функциональностью для создания полнофункционального веб-приложения, такого как PlayPod, особенно в контексте обучения или небольших проектов.
